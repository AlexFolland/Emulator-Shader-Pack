 /*
    cgwg's CRT shader

    Copyright (C) 2010 cgwg

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2 of the License, or (at your option)
    any later version.

    (cgwg gave their consent to have their code distributed under the GPL in
    this message:

        http://board.byuu.org/viewtopic.php?p=26075#p26075

        "Feel free to distribute my shaders under the GPL. After all, the
        barrel distortion code was taken from the Curvature shader, which is
        under the GPL."
    )
*/

struct tex_coords
{
   float2 c01; 
   float2 c11; 
   float2 c21;
   float2 c31;
   float2 c02;
   float2 c12; 
   float2 c22;
   float2 c32; 
   float2 one;
   float2 tex;
   float mod_val;
};

struct input
{
   float2 video_size;
   float2 texture_size;
   float2 output_size;
};

void main_vertex
(
   float4 position : POSITION,
   out float4 oPosition : POSITION,
   uniform float4x4 modelViewProj,

   float4 color : COLOR,
   out float4 oColor : COLOR,

   float2 tex : TEXCOORD,

   uniform input IN,
   out tex_coords coords
)
{
   oPosition = mul(modelViewProj, position);
   oColor = color;

   float2 delta = 1.0 / IN.texture_size;
   float dx = delta.x;
   float dy = delta.y;

   float2 tex_ = tex + float2(0.0, -0.5 * IN.video_size.y * delta.y / IN.output_size.y);
   float mod_val = tex.x * IN.output_size.x * IN.texture_size.x / IN.video_size.x;

   coords = tex_coords (
      tex_ + float2(-dx, 0.0),
      tex_ + float2(0.0, 0.0),
      tex_ + float2(dx, 0.0),
      tex_ + float2(2.0 * dx, 0.0),
      tex_ + float2(-dx, dy),
      tex_ + float2(0.0, dy),
      tex_ + float2(dx, dy),
      tex_ + float2(2.0 * dx, dy),
      delta,
      tex,
      mod_val
   );
}


#define TEX2D(c) tex2D(s0 ,(c))
#define PI 3.141592653589
#define gamma 2.7

// Gotta love branchless :3
float4 less_than(float4 vals, float4 condition)
{
   float4 res = float4(1.0) + condition - vals; 
   return saturate(floor(res));
}

float4 main_fragment(in tex_coords co, uniform input IN, uniform sampler2D s0 : TEXUNIT0, float2 tex : TEXCOORD) : COLOR
{
   float2 rubyTextureSize = IN.texture_size;
   float2 rubyInputSize = IN.video_size;
   float2 rubyOutputSize = IN.output_size;

   float2 xy = co.c11;
   float2 uv_ratio = frac(xy * rubyTextureSize);
   float4 coeffs = float4(1.0 + uv_ratio.x, uv_ratio.x, 1.0 - uv_ratio.x, 2.0 - uv_ratio.x);
   float4 bvecs = less_than(abs(coeffs), float4(0.01));

   float4 coeff_square_r = 1.0 / (coeffs * coeffs);

   float4 texels[8];
   texels[0] = TEX2D(co.c01);
   texels[1] = TEX2D(co.c11);
   texels[2] = TEX2D(co.c21);
   texels[3] = TEX2D(co.c31);
   texels[4] = TEX2D(co.c02);
   texels[5] = TEX2D(co.c12);
   texels[6] = TEX2D(co.c22);
   texels[7] = TEX2D(co.c32);
   float4x4 texes0 = float4x4(texels[0], texels[1], texels[2], texels[3]);
   float4x4 texes1 = float4x4(texels[4], texels[5], texels[6], texels[7]);

   float2 one = co.one;

   coeffs = lerp((sin(PI * coeffs) * sin(0.5 * PI * coeffs)) * coeff_square_r, float4(1.0), bvecs);
   xy.x = floor(xy.x / one.x) * one.x;

   float4 col, col2;

   coeffs = coeffs / dot(coeffs, float(1.0));

   float4 weights = float4(3.33 * uv_ratio.y);
   float4 weights2 = float4((1.0 - uv_ratio.y) * 3.33);

   col = saturate(mul(coeffs, texes0));
   col2 = saturate(mul(coeffs, texes1));

   float4 wid = float4(2.0) + 2.0 * pow(col, float4(4.0));
   float4 wid2 = float4(2.0) + 2.0 * pow(col2, float4(4.0));

   col = pow(col, float4(gamma));
   col2 = pow(col2, float4(gamma));

   float4 sqrt1 = rsqrt(0.5 * wid);
   float4 sqrt2 = rsqrt(0.5 * wid2);

   float4 pow_mul1 = weights * sqrt1;
   float4 pow_mul2 = weights2 * sqrt2;

   float4 div1 = 0.392 + 0.1320 * wid;
   float4 div2 = 0.392 + 0.1320 * wid2;

   float4 pow1 = -pow(pow_mul1, wid);
   float4 pow2 = -pow(pow_mul2, wid2);

   weights = exp(pow1) / div1;
   weights2 = exp(pow2) / div2;

   float4 multi = col * weights + col2 * weights2;

   float4 mcol = float4(1.0);
   if (fmod(co.mod_val.x, 2.0) < 1.0)
      mcol.g = 0.7;
   else
      mcol.rb = float2(0.7);

   return pow(mcol * multi, float4(0.454545));
}
